<?php

/**
 * Form Parser for database input. 
 * 
 * Will read the output generated by Input_Database and parse it into
 * an array readable by Form_Writer
 *
 * @author  Lukas Niederberger <lukas.niederberger@gibmit.ch>
 */
class Form_Parser_DB {

	/**
	 * Parse a single line to evaluate what kind of form element it is.
	 *
	 * Calls the appropriate parsing method after determining the type.
	 *
	 * @throws  InvalidArgumentException If the passed array is not formatted correctly
	 * @param  array $line  Output from Input_Database, describes a single table column.
	 * @return array        An array representing the parsed data.
	 */
	public function parseLine($line)
	{
		// Determine if the input array is formatted correctly
		if ( ! is_array($line) )
		{
			throw new InvalidArgumentException('Input is not an array.');
		}
		else
		{
			if ( ! array_key_exists('Type', $line) ||
				 ! array_key_exists('Extra', $line) ||
				 ! array_key_exists('Field', $line) ||
				 ! array_key_exists('Null', $line)
			)
			{
				throw new InvalidArgumentException('Invalid input array.');
			}
		}

		// Determine the data type of the passed table column.
		$type = strtolower(explode('(', $line['Type'])[0]);

		// Skip field if it is an auto_increment.
		if ($line['Extra'] === 'auto_increment')
		{
			return false;
		}

		// Call the appropriate parsing function for the determined data type.
		switch ($type)
		{
			case 'enum':
				return $this->parseEnum($line);

			case 'set':
				return $this->parseSet($line);

			case 'boolean':
			case 'bool':
			case 'bit':
				return $this->parseBool($line);

			case 'text':
			case 'tinytext':
			case 'mediumtext':
			case 'longtext':
				return $this->parseText($line);

			case 'blob':
			case 'tinyblob':
			case 'mediumblob':
			case 'longblob':
				return $this->parseBlob($line);

			case 'date':
			case 'datetime':
			case 'timestamp':
			case 'time':
			case 'year':
				return $this->parseDateTime($line, $type);

			case 'int':
			case 'tinyint':
			case 'smallint':
			case 'mediumint':
			case 'bigint':
			case 'float':
			case 'double':
			case 'decimal':
				return $this->parseNum($line, $type);
			
			default:
				return $this->parseInput($line);
		}
	}

	/**
	 * Parser for ENUM Types. 5 or more ENUM options will generate a Select dropdown,
	 * less than 5 Options will generate a group of radio buttons.
	 * @param  array  $line Single row of the database result.
	 * @return array        Array readable by Form_Writer representing the form field.
	 */
	protected function parseEnum(array $line)
	{
		// Get all options from the enum or set.
		$start = strpos($line['Type'], '(')+1;
		$length = strpos($line['Type'], ')')-$start;
		$enum_options = substr($line['Type'], $start, $length);
		$options = str_getcsv($enum_options, ',', "'");

		$result = $this->prepareResult($line);

		// Generate the options array for Form_Writer
		foreach ($options as $key => $o)
		{
			$result['options'][$key]['label'] = $o;
			$result['options'][$key]['value'] = $o;
		}
		
		if ( count($options) < 5)
		{
			// Less than 5 options -> treat as radio button
			$result['type'] = 'input';
			$result['attributes']['type'] = 'radio';
		}
		else
		{
			// More than 5 options -> treat as dropdown select.
			$result['type'] = 'select';
		}

		return $result;
	}

	/**
	 * Parser for SET type. Uses parseEnum for basic data and changes Radiobuttons to checkboxes,
	 * select dropdown to multiselect list.
	 * @param  array  $line Single row of the databse result
	 * @return array        Array readable by Form_Writer representing the form field.
	 */
	protected function parseSet(array $line)
	{
		$result = $this->parseEnum($line);

		if ( $result['type'] == 'select' )
		{
			$result['attributes']['multiple'] = 'multiple';
		}
		else
		{
			$result['attributes']['type'] = 'checkbox';
		}

		return $result;
	}

	/**
	 * Parser for BOOLEAN Type
	 * @param  array  $line [description]
	 * @return [type]       [description]
	 */
	protected function parseBool(array $line)
	{
		$result = $this->prepareResult($line);
		$result['required'] = false;
		$result['attributes']['type'] = 'checkbox';

		return $result;
	}

	/**
	 * Parser for data type TEXT. Will generate a Textarea. 
	 * VARCHAR fields with a length greater than 255 will be redirected here.
	 * 	
	 * @param  array  $line Single row of the database result for DESCRIBE
	 * @return array        Array readable by Form_Writer
	 */
	protected function parseText(array $line)
	{
		$result = $this->prepareResult($line);
		$result['type'] = 'textarea';

		return $result;
	}

	/**
	 * Parser for data type BLOB. Will generate a field input.
	 * @param  array  $line Single row of the database result for DESCRIBE
	 * @return array        Array readable by Form_Writer
	 */
	protected function parseBlob(array $line)
	{
		$result = $this->prepareResult($line);

		$result['attributes'] = ['type' => 'file'];

		return $result;
	}

	/**
	 * Parser for Date and Time datatypes. Will generate a date or datetime input.
	 * @param  array  $line Single row of the database result for DESCRIBE
	 * @param  string $type Datatype determined in parseLine()
	 * @return array        Array readable by Form_Writer
	 */
	protected function parseDateTime(array $line, $type)
	{
		$result = $this->prepareResult($line);

		// If it is a date/time field, datetime input will be generated.
		// otherwise, date only will be assumed.
		if ($type == 'datetime' || $type == 'timestamp')
		{
			$result['attributes']['type'] = 'datetime-local';
		} 
		else 
		{
			$result['attributes']['type'] = 'date';
		}

		return $result;
	}

	/**
	 * Parser for numeric datatypes. Will generate a number input.
	 * @param  array  $line Single row of the database result for DESCRIBE
	 * @param  string $type Datatype determined in parseLine()
	 * @return array        Array readable by Form_Writer
	 */
	protected function parseNum(array $line, $type)
	{
		$result = $this->prepareResult($line);

		// Determine the max length
		$start = strpos($line['Type'], '(')+1;
		$length = strpos($line['Type'], ')')-$start;
		$maxlength = substr($line['Type'], $start, $length);

		if ( $type == 'tinyint' && $maxlength == '1')
		{
			return $this->parseBool($line);
		}

		$result['attributes']['type'] = 'number';

		// Check if the number is saved unsigned
		$unsigned = (strpos($line['Type'], 'unsigned') !== false);

		// Determine the min and max size for the number.
		switch ($type) {
			case 'tinyint':
				$result['attributes']['min'] = $unsigned ? 0 : -128;
				$result['attributes']['max'] = $unsigned ? 255 : 127;
				break;
			case 'smallint':
				$result['attributes']['min'] = $unsigned ? 0 : -32768;
				$result['attributes']['max'] = $unsigned ? 65535 : 32787;
				break;
			case 'mediumint':
				$result['attributes']['min'] = $unsigned ? 0 : -8388608;
				$result['attributes']['max'] = $unsigned ? 16777215 : 8388607;
				break;
			case 'int':
				$result['attributes']['min'] = $unsigned ? 0 : -2147483648;
				$result['attributes']['max'] = $unsigned ? 4294967295 : 2147483647;
				break;
			case 'bigint':
				$result['attributes']['min'] = $unsigned ? 0 : -9223372036854775808;
				$result['attributes']['max'] = $unsigned ? 18446744073709551615 : 9223372036854775807;
				break;
			default:
				$result['attributes']['step'] = "any";
		}

		return $result;
	}

	/**
	 * Parser for short text and other datatypes. Will generate a text input
	 * If the string "password" is found in the name of the field, type password will be assumed.
	 * @param  array  $line Single row of the database result for DESCRIBE
	 * @return array        Array readable by Form_Writer
	 */
	protected function parseInput(array $line)
	{
		$result = $this->prepareResult($line);

		// Check if the field name implies a specific input type
		if ( (strpos($line['Field'], 'password') !== false)
		  || (strpos($line['Field'], 'passwort') !== false) )
		{
			$result['attributes']['type'] = 'password';
		}
		else if ( (strpos($line['Field'], 'email')  !== false) )
		{
			$result['attributes']['type'] = 'email';
		}
		else if ( (strpos($line['Field'], 'url')  !== false)
			   || (strpos($line['Field'], 'link') !== false) )
		{
			$result['attributes']['type'] = 'url';
		}
		else
		{
			$result['attributes']['type'] = 'text';	
		}

		// Determine the max length
		$start = strpos($line['Type'], '(')+1;
		$length = strpos($line['Type'], ')')-$start;
		$maxlength = substr($line['Type'], $start, $length);

		// Set the maxlength attribute if applicable.
		if ( is_numeric($maxlength) )
		{
			// Fields with a length greater than 255 will be treated as textarea,
			// type password excepted.
			if ( $maxlength > 255 && ($result['attributes']['type'] === 'text') )
			{
				$result['type'] = 'textarea';
				unset($result['attributes']['type']);
			}

			$result['attributes']['maxlength'] = $maxlength;
		}

		return $result;
	}

	/**
	 * Prepare a basic result array that will satisfy Form_Writer
	 *
	 * Also handles data from the input common to all data types.
	 * 
	 * @param  array  $line Input data
	 * @return array        Associative array that will satisfy Form_Writer.
	 */
	protected function prepareResult(array $line)
	{
		$result['type'] = 'input';
		$result['label'] = ucfirst(str_replace('_', ' ', $line['Field']));
		$result['name'] = $line['Field'];
		$result['required'] = ($line['Null'] === 'NO');
		$result['options'] = [];
		$result['attributes'] = [];

		return $result;
	}

}